# Архитектура SQLite: системная БД и отдельная БД на проект

## Две роли БД

1. **Системная (одна, всегда одна)**  
   Файл, например: `userData/crawlite.sqlite` или `userData/system.sqlite`.  
   В ней таблица проектов и настройки приложения.  
   Подключается при старте приложения и живёт всё время.

2. **Проектные (много)**  
   По одному файлу на проект: `userData/projects/<id>.sqlite` (или `<slug>.sqlite`).  
   В каждом — только данные этого проекта (urls, pages и т.д.).  
   Открываются и закрываются по мере необходимости.

## Как «подключается» и «переподключается»

**БД сама не переподключается.** Решение принимает приложение: какую проектную БД считать текущей и к какому файлу обращаться.

- В памяти приложения хранится **текущий проект**: `currentProjectId` (и при необходимости путь к файлу `currentProjectDbPath`).
- Все операции с URL/страницами идут **в файл текущего проекта**.
- При смене проекта приложение просто меняет `currentProjectId` и путь к файлу, а при обращении к БД открывает/использует нужный файл.

То есть «переподключение» — это не одна и та же подключение, которая куда-то переключается, а **выбор другого файла БД** (другого проекта).

## Создание проекта

1. Пользователь нажимает «Создать проект», вводит имя.
2. Генерируется id (UUID или slug).
3. В **системной БД** делается INSERT в таблицу проектов: `(id, name, db_path, created_at)`, `db_path` = например `projects/abc-123.sqlite`.
4. Создаётся файл по этому пути.
5. В этом файле выполняется схема проектной БД (CREATE TABLE urls и т.д.).
6. В приложении выставляется текущий проект: `currentProjectId = новый id`, дальше все операции — в этот файл.

## Выбор проекта из списка

1. Список проектов читается из **системной БД** (таблица проектов).
2. Пользователь выбирает проект.
3. Приложение по выбранному id достаёт из системной БД `db_path` этого проекта.
4. **Вариант A:** закрываете соединение с предыдущей проектной БД, открываете соединение с файлом из `db_path` выбранного проекта. В коде храните одно «текущее» соединение к проектной БД.
5. **Вариант B:** всегда одно активное соединение к проектной БД; при смене проекта закрыть его и открыть новое к файлу выбранного проекта.

Системная БД при этом может быть вторым, отдельным соединением (всегда открыта).

## Варианты архитектуры под рост (10k–100k на проект, до 100 проектов)

| Вариант | Описание | Плюсы | Минусы |
|--------|----------|--------|--------|
| **A. Одна таблица `urls` + `project_id`** | Одна БД, одна таблица, колонка `project_id`, индекс по (project_id, url). | Простая схема, один файл, 10M строк для SQLite нормально. | Один файл растёт; бэкап/удаление «по проекту» только через DELETE. |
| **B. Реестр + таблица на проект в одной БД** | Системные таблицы + реестр `project_tables` + таблицы `urls_1`, `urls_2`, … | Чёткое разделение по проектам, удаление проекта = DROP TABLE. | Много таблиц, миграции схемы сложнее. |
| **C. Одна системная БД + отдельный файл БД на проект** | `crawlite.sqlite` — только проекты и настройки; для каждого проекта свой файл `data/project_<id>.sqlite` с таблицей `urls`. | Нет одного гигантского файла, удобно бэкапить/удалять проект целиком, изоляция. | Нужно открывать/закрывать несколько соединений. |

**Рекомендация:** вариант C (отдельная БД на проект) или A (одна таблица с `project_id`) + политика очистки/архивации старых данных.

## Сдерживание роста

- **Ограничение по времени:** хранить только последние N месяцев или последние N записей по проекту.
- **Денормализация:** в БД — минимум полей (url, project_id, статус, дата); тяжёлые данные — в файлы.
- **WAL + VACUUM:** включить WAL для SQLite, периодически делать VACUUM.
